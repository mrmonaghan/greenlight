import { Injectable, Logger } from '@nestjs/common';
import { createEventHandler } from '@octokit/webhooks';
import { EventHandler } from '@octokit/webhooks/dist-types/event-handler';
import { Octokit } from '@octokit/rest';
import { ConfigService } from '@nestjs/config';
import { minimatch } from 'minimatch';

const SuccessEmoji = ":white_check_mark:";
const FailureEmoji = ":x:";
const PendingEmoji = ":yellow_circle:";
const MissingEmoji = ":eyes:";
const BeginCommentMarkdown = `<!-- Greenlight Comment -->`;
const EndCommentMarkdown = `<!-- End Greenlight Comment -->`;

@Injectable()
export class GithubService {
    private logger = new Logger("github-service");
    private handler: EventHandler;
    private client: Octokit = new Octokit({
        auth: process.env.GITHUB_TOKEN,
    });

    private name: string;
    private requires: string []
    private ignores: string []
    private ignoreBranchPatterns: string[];
    private includeBranchPatterns: string[];
    private strictStatuses: boolean;
    private enableComment: boolean;

    constructor(private configService: ConfigService) {

        // start the event handler
        this.handler = createEventHandler({
            secret: process.env.GITHUB_WEBHOOK_SECRET,
        });
        
        // load configuration
        // custom service name
        this.name = 'greenlight';

        // status checks to ignore, always include own name
        const configIgnores = this.configService.get<string[]>('status.ignore') || [];
        configIgnores.push(this.name);
        this.ignores = configIgnores

        // status checks to require
        this.requires = this.configService.get<string[]>('status.require') || [];

        // strict status checks
        this.strictStatuses = this.configService.get<boolean>('status.strict') || false;
        this.logger.debug(`strict statuses: ${this.strictStatuses}`);

        // branch patterns to include
        // if no patterns are provided, include all branches
        this.includeBranchPatterns = this.configService.get<string[]>('branch.include') || [];

        // branch patterns to ignore
        // if no patterns are provided, ignore no branches
        this.ignoreBranchPatterns = this.configService.get<string[]>('branch.ignore') || [];

        // enable comment
        // enabled by default
        this.enableComment = this.configService.get<boolean>('enableComment') || true;

        // ping events
        // this is used to verify the webhook after creation
        this.handler.on('ping', async ({ id, name, payload }) => {
            this.handlePingEvent({ id, name });
        });
        

        // status events
        this.handler.on('status', async ({ id, name, payload }) => {

            // capture values
            const owner = payload.repository.owner.login;
            const repo = payload.repository.name;
            const sha = payload.sha;
            this.logger.debug(`handling status event: id ${id}, owner ${owner}, repo ${repo}, sha ${sha}`);
            
            // ignore status events generated by self
            if (payload.context === this.name) {
                this.logger.debug(`ignoring self status event id: ${id}`);
                return;
            }

            // validate the branch
            if (!this.branchIsValid(payload.branches[0].name)) {
                this.logger.debug(`branch ${payload.branches[0].name} is not valid, ignoring event`);
                return;
            }

            // confirm a PR exists
            const pr = await this.getPullRequest(payload);
            if (!pr) {
                this.logger.debug(`no PR found for sha: ${payload.sha}, ignoring event`);
                return;
            }

            // evaluate statuses
            const { state, existingState, present, missing } = await this.evaluate({ owner, repo, sha });

            // upsert comment if enabled
            if (this.enableComment) {
                const commentTitle = this.markdownTitle(state);
                const commentBody = this.markdownBody(state, present, missing, this.ignores);
                const commentFooter = this.markdownFooter(name, id);
                const comment = this.markdownComment(commentTitle, commentBody, commentFooter);
                await this.comment(owner, repo, pr.number, comment);
            }           

            // check if the status is already set
            if (state === existingState) {
                this.logger.debug(`status is already ${state}, skipping update`);
                return;
            }
            // set the status
            await this.status(owner, repo, sha, payload.repository.html_url, state);
        });

        // comment events
        this.handler.on('issue_comment', async ({ id, name, payload }) => {
            this.logger.debug(`handling ${name} event id: ${id}`);
            if (payload.action !== 'created' || !payload.comment.body.startsWith("/greenlight")) {
                this.logger.debug(`ignoring comment event id: ${id}`);
                return;
            }
            const command = payload.comment.body.split(" ")[1];
            if (command === "refresh") {
                this.logger.debug(`refreshing status for PR: ${payload.issue.number}`);
                const owner = payload.repository.owner.login;
                const repo = payload.repository.name;
                const sha = await this.getPRHeadSha(owner, repo, payload.issue.number);
                const { state, existingState, present, missing } = await this.evaluate({ owner, repo, sha });
                
                if (this.enableComment) {
                    const commentTitle = this.markdownTitle(state);
                    const commentBody = this.markdownBody(state, present, missing, this.ignores);
                    const commentFooter = this.markdownFooter(name, payload.comment.html_url);
                    const comment = this.markdownComment(commentTitle, commentBody, commentFooter);
                    await this.comment(owner, repo, payload.issue.number, comment);
                }
                
                if (state !== existingState && sha) {
                    await this.status(owner, repo, sha, payload.repository.html_url, state);
                }

                await this.createCommentReaction(owner, repo, payload.comment.id, "+1");
                this.logger.debug(`refreshed status for PR: ${payload.issue.number}`);
            } else {
                await this.createCommentReaction(payload.repository.owner.login, payload.repository.name, payload.comment.id, "-1");
                this.logger.log(`unknown command: ${command}, -1 reaction added to comment id: ${payload.comment.id}`);
            }
        });

    }

    handlePingEvent({ id, name }) {
        this.logger.log(`Received ping event: ${name} with id: ${id}`);
        return;
    }

    // main entrypoint for the controller
    async handleWebhookEvent(payload: any, headers: any) {
        try {
            await this.handler.receive({
                id: headers['x-github-delivery'],
                name: headers['x-github-event'],
                payload: payload,
            });
        } catch (error) {
            this.logger.error(`Error handling webhook event: ${error}`);
        }
    }

    // retrieve a list of status events for a given sha and compare them to required/ignored statuses
    // return the state of the PR based on the statuses, along with a list of present `status` objects and missing status names
    async evaluate({ owner, repo, sha }): Promise<{state: string, existingState: string, present: any[], missing: string[]}> {
        this.logger.debug(`evaluating statuses: owner ${owner}, repo ${repo}, sha ${sha}`);
        const statuses = await this.client.repos.listCommitStatusesForRef({
            owner: owner,
            repo: repo,
            ref: sha,
        });  

        // get only the most recent instance of each status for the provided sha
        const uniqueStatuses = new Map<string, typeof statuses.data[0]>();
        for (const status of statuses.data) {
            if (!uniqueStatuses.has(status.context) || new Date(status.created_at) > new Date(uniqueStatuses.get(status.context)?.created_at ?? 0)) {
                    uniqueStatuses.set(status.context, status);
            }
        }
        

        // check if the self status is already present
        let selfStatus: any;
        if (uniqueStatuses.has(this.name)) {
            selfStatus = uniqueStatuses.get(this.name);
            uniqueStatuses.delete(this.name);
            this.logger.debug(`found existing self status: ${selfStatus.id}`);

        } else {
            selfStatus = {
                state: "success",
                context: this.name,
            };
        }

        const mostRecentStatuses = Array.from(uniqueStatuses.values());

        // filter out ignores
        const ignoredStatuses: string[] = [];
        let filteredStatuses = mostRecentStatuses.filter((status) => {
            if (this.ignores.includes(status.context)) {
                ignoredStatuses.push(status.context);
                return false;
            }
            return true;
        });

        // if strictStatuses is enabled, filter out all statuses that are not explicitly required.
        const present = this.strictStatuses ? filteredStatuses.filter((status => this.requires.includes(status.context))) : filteredStatuses;
        
        const hasFailures = present.some((status) => status.state === "failure");
        const hasPending = present.some((status) => status.state === "pending");
        const missing = this.requires.filter((status) => !filteredStatuses.some((s) => s.context === status));

        if (hasFailures) {
            return {state: "failure", existingState: selfStatus.state, present: present, missing: missing};
        }

        if (hasPending || missing.length > 0) {
            return {state: "pending", existingState: selfStatus.state, present: present, missing: missing};
        }
        
        return {state: "success", existingState: selfStatus.state, present: present, missing: missing};
    }

    // check if the branch is valid based on provided glob patterns
    branchIsValid(branch: string): boolean {
        // Check if the branch is ignored
        for (const pattern of this.ignoreBranchPatterns) {
            if (minimatch(branch, pattern)) {
                this.logger.debug(`branch ${branch} is ignored by pattern ${pattern}`);
                return false;
            }
        }
        let allowed = true;
        for (const pattern of this.includeBranchPatterns) {
            if (minimatch(branch, pattern)) {
                this.logger.debug(`branch ${branch} is allowed by include pattern ${pattern}`);
                allowed = true;
                break;
            }
            this.logger.debug(`branch ${branch} is not allowed by any include pattern`);
        }
        return allowed;
    }
    
    // set the status of a commit
    async status(owner: string, repo: string, sha: string, url: string, status: string) {
        let description = "";
        switch (status) {
            case "success":
                description = "All required checks passed!";
                break;
            case "error":
            case "failure":
                description = "One or more required checks failed.";
                break;
            case "pending":
                description = "One or more required checks are in progress...";
                break;
        }
        await this.client.repos.createCommitStatus({
            owner: owner,
            repo: repo,
            sha: sha,
            state: status as "success" | "pending" | "failure" | "error",
            target_url: url,
            description: description,
            context: this.name,
        }).then((response) => {
            this.logger.debug(`set status to ${status} for sha ${sha}`);
        }
        ).catch((error) => {
            this.logger.error(`error setting status to ${status} for ${sha}: ${error}`);
        }
        );
    }

    async getPullRequest(payload: any) {
        try {
            const response = await this.client.repos.listPullRequestsAssociatedWithCommit({
                owner: payload.repository.owner.login,
                repo: payload.repository.name,
                commit_sha: payload.sha,
            });
            return response.data.length > 0 ? response.data[0] : null;
        } catch (error) {
            this.logger.error(`Error getting PR: ${error}`);
            return null;
        }
    }

    // annoyingly, the PR head sha is not included in the issue_comment event
    async getPRHeadSha(owner: string, repo: string, pr_number: number) {
        try {
            const response = await this.client.pulls.get({
                owner: owner,
                repo: repo,
                pull_number: pr_number,
            });
            return response.data.head.sha;
        } catch (error) {
            this.logger.error(`Error getting PR head sha: ${error}`);
            return null;
        }
    }

    async createCommentReaction(owner: string, repo: string, commentId: number, reaction: string) {
        try {
            const response = await this.client.reactions.createForIssueComment({
                owner: owner,
                repo: repo,
                comment_id: commentId,
                content: reaction as "+1" | "-1" | "laugh" | "hooray" | "confused" | "heart" | "rocket" | "eyes",    
            });
            this.logger.debug(`added '${reaction}' reaction to comment with id: ${commentId}`);
            return response.data.id;
        } catch (error) {
            this.logger.error(`error adding '${reaction}' reaction to comment: ${error}`);
            return null;
        }
    }

    async deleteCommentReaction(owner, repo, commentId, reactionId) {
        try {
            await this.client.reactions.deleteForIssueComment({
                owner: owner,
                repo: repo,
                comment_id: commentId,
                reaction_id: reactionId,
            });
            this.logger.debug(`deleted reaction ${reactionId} from comment ${commentId}`);
        } catch (error) {
            this.logger.error(`error deleting ${reactionId} reaction from comment ${commentId}: ${error}`);
        }
    }
        
    async comment(owner: string, repo: string, pr_number: number, comment: string) {
        try {
            const response = await this.client.issues.listComments({
                owner: owner,
                repo: repo,
                issue_number: pr_number,
            });
            const existingComment = response.data.find((comment) => comment.body?.startsWith(BeginCommentMarkdown) && comment.body?.endsWith(EndCommentMarkdown));
            const commentId = existingComment ? existingComment.id : 0;

            const markdownContent = `${BeginCommentMarkdown}\n${comment}\n${EndCommentMarkdown}`;
            if (commentId > 0) {
                await this.client.issues.updateComment({
                    owner: owner,
                    repo: repo,
                    comment_id: commentId,
                    body: markdownContent,
                });
                this.logger.debug(`updated comment with id: ${commentId}`);
            } else {
                const createResponse = await this.client.issues.createComment({
                    owner: owner,
                    repo: repo,
                    issue_number: pr_number,
                    body: markdownContent,
                });
                this.logger.debug(`created comment with id: ${createResponse.data.id}`);
            }
        } catch (error) {
            this.logger.error(`error handling comment: ${error}`);
        }
    }
    
    markdownComment(title: string, body: string, footer: string): string {
        return `${title}\n\n${body}\n\n${footer}`;
    }

    markdownTitle(state: string): string {
        switch (state) {
            case "failure":
                return `## :red_circle: Greenlight - PR Mergeability`;
            case "pending":
                return `## :yellow_circle: Greenlight - PR Mergeability`;
            default:
                return `## :green_circle: Greenlight - PR Mergeability`;
        }
    }

    markdownBody(state: string, present: any, missing: string[], ignored: string[]): string {
        let body = "";
        if (state === "failure") {
            body += `Your pull request is **not mergeable.** One ore more required status checks have failed.\n\n`;
        } else if (state === "pending") {
            body += `Your pull request is **not yet mergeable.** One ore more required status checks are still in progress.\n\n`;
        } else {
            body += `Your pull request is **mergeable!** All required status checks have passed.\n\n`;
        }

        for (const status of present) {
            if (status.state === "failure") {
                body += `${FailureEmoji} ${status.context}\n`;
            }
        }

        for (const status of present) {
            if (status.state === "success") {
                body += `${SuccessEmoji} ${status.context}\n`;
            }
        }

        for (const status of present) {
            if (status.state === "pending") {
                body += `${PendingEmoji} ${status.context}\n`;
            }
        }

        if (missing.length > 0) {
            for (const status of missing) {
                body += `${MissingEmoji} *Waiting for* **${status}** *status to be reported...*\n`;
            }
        }

        if (ignored.length > 0) {
            body += `<details><summary>Ignored status checks</summary><pre>${ignored.join("\n")}</pre></details>\n\n`;
        }
        return body;
    }
    
    markdownFooter(event: string, value: string): string {
        let v = "";
        if (event == "status") {
            v = `Triggered by webhook event ID ${value}`;
        } else if (event == "issue_comment") {
            v = `Refreshed by [this comment](${value})`;
        }
        return `---\n<sub>${v}</sub>`;
    }
}

